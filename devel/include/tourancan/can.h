// Generated by gencpp from file tourancan/can.msg
// DO NOT EDIT!


#ifndef TOURANCAN_MESSAGE_CAN_H
#define TOURANCAN_MESSAGE_CAN_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace tourancan
{
template <class ContainerAllocator>
struct can_
{
  typedef can_<ContainerAllocator> Type;

  can_()
    : LWI_Sensorstatus(0)
    , LWI_StrWhlAngleSt(0)
    , LWI_StrWhlAngleSize(0.0)
    , LWI_StrWhlAngleDrt(0)
    , LWI_StrWhlSpeedDrt(0)
    , LWI_StrWhlSpeedSize(0.0)
    , Stalls(0.0)
    , TargetStalls(0.0)
    , EngineSpeedState(0)
    , EngineSpeed(0.0)
    , ACCSignalContinuity(0)
    , Speed(0.0)
    , ESP_SystemStatus(0)
    , SpeedState(0)
    , LF_WhlSpd(0.0)
    , LR_WhlSpd(0.0)
    , RF_WhlSpd(0.0)
    , RR_WhlSpd(0.0)
    , aPedalPercent(0.0)
    , aPedalPercentSt(0)
    , ThrottleGradientSize(0.0)
    , ThrottleGradientPN(0)
    , EngNeutralTorque(0)
    , BrakeSwitch(0)
    , EPSRxHCA_Status(0.0)
    , EPS_StrWhlTorque(0.0)
    , EPS_StrWhlTorqueDrt(0)
    , EPS_StrWhlTorqueSt(0)
    , ExpStrWhlTorque(0.0)
    , HCATranCycle(0)
    , ExpStrWhlTorqueDrt(0)
    , HCA_Status(0.0)
    , EngTorqueCoefficient(0.0)
    , ThtottlePosition(0.0)
    , aPedalPosition(0.0)
    , PLA_CRC(0.0)
    , PLA_BZ(0.0)
    , PLABrkRqtSt(0)
    , PLAExpStrWhlAngle(0.0)
    , PLAExpStrWhlAngleDrt(0)
    , PLARequestStatus(0.0)
    , PLABrkTorque(0.0)
    , PLABrkDeceleration(0.0)
    , PLABrkEnable(0)
    , BrkTrqAndDeceSwt(0)
    , PLAParking(0)
    , PLAPrkDistance(0.0)
    , PLASignalTxCyclic(0)
    , YawState(0)
    , axState(0)
    , ayState(0)
    , ay(0.0)
    , ax(0.0)
    , YawRate(0.0)
    , YawToRight(0)
    , BrakePressureState(0)
    , BrakePressure(0.0)
    , LF_WhlSpdDrt(0.0)
    , LR_WhlSpdDrt(0.0)
    , RF_WhlSpdDrt(0.0)
    , RR_WhlSpdDrt(0.0)
    , ACC_02CRC(0.0)
    , ACC_02BZ(0.0)
    , ExpectedSpeed(0.0)
    , SpacingFactor(0.0)
    , NoiseAlarm(0.0)
    , SetSpacing(0.0)
    , ImageAlarm(0)
    , ACC02Status(0.0)
    , ACC_06CRC(0.0)
    , ACC_06BZ(0.0)
    , aLowerDeviation(0.0)
    , aExpectedValue(0.0)
    , aUpperDeviation(0.0)
    , DclrtGradRmdValue(0.0)
    , AclrtGradRmdValue(0.0)
    , StartRequest06(0)
    , ParkingRequest06(0)
    , ACC06Status(0.0)
    , ACC_07CRC(0.0)
    , ACC_07BZ(0.0)
    , ParkingDistance(0.0)
    , ParkingRequest07(0)
    , StartRequest07(0)
    , aExpValue(0)
    , EPBFaultStatus(0.0)
    , EPBSwitch(0.0)
    , EPBSwitchState(0)
    , EPB_PressingForce(0.0)
    , EPB_Status(0.0)
    , TSK_status(0.0)  {
    }
  can_(const ContainerAllocator& _alloc)
    : LWI_Sensorstatus(0)
    , LWI_StrWhlAngleSt(0)
    , LWI_StrWhlAngleSize(0.0)
    , LWI_StrWhlAngleDrt(0)
    , LWI_StrWhlSpeedDrt(0)
    , LWI_StrWhlSpeedSize(0.0)
    , Stalls(0.0)
    , TargetStalls(0.0)
    , EngineSpeedState(0)
    , EngineSpeed(0.0)
    , ACCSignalContinuity(0)
    , Speed(0.0)
    , ESP_SystemStatus(0)
    , SpeedState(0)
    , LF_WhlSpd(0.0)
    , LR_WhlSpd(0.0)
    , RF_WhlSpd(0.0)
    , RR_WhlSpd(0.0)
    , aPedalPercent(0.0)
    , aPedalPercentSt(0)
    , ThrottleGradientSize(0.0)
    , ThrottleGradientPN(0)
    , EngNeutralTorque(0)
    , BrakeSwitch(0)
    , EPSRxHCA_Status(0.0)
    , EPS_StrWhlTorque(0.0)
    , EPS_StrWhlTorqueDrt(0)
    , EPS_StrWhlTorqueSt(0)
    , ExpStrWhlTorque(0.0)
    , HCATranCycle(0)
    , ExpStrWhlTorqueDrt(0)
    , HCA_Status(0.0)
    , EngTorqueCoefficient(0.0)
    , ThtottlePosition(0.0)
    , aPedalPosition(0.0)
    , PLA_CRC(0.0)
    , PLA_BZ(0.0)
    , PLABrkRqtSt(0)
    , PLAExpStrWhlAngle(0.0)
    , PLAExpStrWhlAngleDrt(0)
    , PLARequestStatus(0.0)
    , PLABrkTorque(0.0)
    , PLABrkDeceleration(0.0)
    , PLABrkEnable(0)
    , BrkTrqAndDeceSwt(0)
    , PLAParking(0)
    , PLAPrkDistance(0.0)
    , PLASignalTxCyclic(0)
    , YawState(0)
    , axState(0)
    , ayState(0)
    , ay(0.0)
    , ax(0.0)
    , YawRate(0.0)
    , YawToRight(0)
    , BrakePressureState(0)
    , BrakePressure(0.0)
    , LF_WhlSpdDrt(0.0)
    , LR_WhlSpdDrt(0.0)
    , RF_WhlSpdDrt(0.0)
    , RR_WhlSpdDrt(0.0)
    , ACC_02CRC(0.0)
    , ACC_02BZ(0.0)
    , ExpectedSpeed(0.0)
    , SpacingFactor(0.0)
    , NoiseAlarm(0.0)
    , SetSpacing(0.0)
    , ImageAlarm(0)
    , ACC02Status(0.0)
    , ACC_06CRC(0.0)
    , ACC_06BZ(0.0)
    , aLowerDeviation(0.0)
    , aExpectedValue(0.0)
    , aUpperDeviation(0.0)
    , DclrtGradRmdValue(0.0)
    , AclrtGradRmdValue(0.0)
    , StartRequest06(0)
    , ParkingRequest06(0)
    , ACC06Status(0.0)
    , ACC_07CRC(0.0)
    , ACC_07BZ(0.0)
    , ParkingDistance(0.0)
    , ParkingRequest07(0)
    , StartRequest07(0)
    , aExpValue(0)
    , EPBFaultStatus(0.0)
    , EPBSwitch(0.0)
    , EPBSwitchState(0)
    , EPB_PressingForce(0.0)
    , EPB_Status(0.0)
    , TSK_status(0.0)  {
  (void)_alloc;
    }



   typedef uint8_t _LWI_Sensorstatus_type;
  _LWI_Sensorstatus_type LWI_Sensorstatus;

   typedef uint8_t _LWI_StrWhlAngleSt_type;
  _LWI_StrWhlAngleSt_type LWI_StrWhlAngleSt;

   typedef float _LWI_StrWhlAngleSize_type;
  _LWI_StrWhlAngleSize_type LWI_StrWhlAngleSize;

   typedef uint8_t _LWI_StrWhlAngleDrt_type;
  _LWI_StrWhlAngleDrt_type LWI_StrWhlAngleDrt;

   typedef uint8_t _LWI_StrWhlSpeedDrt_type;
  _LWI_StrWhlSpeedDrt_type LWI_StrWhlSpeedDrt;

   typedef float _LWI_StrWhlSpeedSize_type;
  _LWI_StrWhlSpeedSize_type LWI_StrWhlSpeedSize;

   typedef float _Stalls_type;
  _Stalls_type Stalls;

   typedef float _TargetStalls_type;
  _TargetStalls_type TargetStalls;

   typedef uint8_t _EngineSpeedState_type;
  _EngineSpeedState_type EngineSpeedState;

   typedef float _EngineSpeed_type;
  _EngineSpeed_type EngineSpeed;

   typedef uint8_t _ACCSignalContinuity_type;
  _ACCSignalContinuity_type ACCSignalContinuity;

   typedef float _Speed_type;
  _Speed_type Speed;

   typedef uint8_t _ESP_SystemStatus_type;
  _ESP_SystemStatus_type ESP_SystemStatus;

   typedef uint8_t _SpeedState_type;
  _SpeedState_type SpeedState;

   typedef float _LF_WhlSpd_type;
  _LF_WhlSpd_type LF_WhlSpd;

   typedef float _LR_WhlSpd_type;
  _LR_WhlSpd_type LR_WhlSpd;

   typedef float _RF_WhlSpd_type;
  _RF_WhlSpd_type RF_WhlSpd;

   typedef float _RR_WhlSpd_type;
  _RR_WhlSpd_type RR_WhlSpd;

   typedef float _aPedalPercent_type;
  _aPedalPercent_type aPedalPercent;

   typedef uint8_t _aPedalPercentSt_type;
  _aPedalPercentSt_type aPedalPercentSt;

   typedef float _ThrottleGradientSize_type;
  _ThrottleGradientSize_type ThrottleGradientSize;

   typedef uint8_t _ThrottleGradientPN_type;
  _ThrottleGradientPN_type ThrottleGradientPN;

   typedef uint8_t _EngNeutralTorque_type;
  _EngNeutralTorque_type EngNeutralTorque;

   typedef uint8_t _BrakeSwitch_type;
  _BrakeSwitch_type BrakeSwitch;

   typedef float _EPSRxHCA_Status_type;
  _EPSRxHCA_Status_type EPSRxHCA_Status;

   typedef float _EPS_StrWhlTorque_type;
  _EPS_StrWhlTorque_type EPS_StrWhlTorque;

   typedef uint8_t _EPS_StrWhlTorqueDrt_type;
  _EPS_StrWhlTorqueDrt_type EPS_StrWhlTorqueDrt;

   typedef uint8_t _EPS_StrWhlTorqueSt_type;
  _EPS_StrWhlTorqueSt_type EPS_StrWhlTorqueSt;

   typedef float _ExpStrWhlTorque_type;
  _ExpStrWhlTorque_type ExpStrWhlTorque;

   typedef uint8_t _HCATranCycle_type;
  _HCATranCycle_type HCATranCycle;

   typedef uint8_t _ExpStrWhlTorqueDrt_type;
  _ExpStrWhlTorqueDrt_type ExpStrWhlTorqueDrt;

   typedef float _HCA_Status_type;
  _HCA_Status_type HCA_Status;

   typedef float _EngTorqueCoefficient_type;
  _EngTorqueCoefficient_type EngTorqueCoefficient;

   typedef float _ThtottlePosition_type;
  _ThtottlePosition_type ThtottlePosition;

   typedef float _aPedalPosition_type;
  _aPedalPosition_type aPedalPosition;

   typedef float _PLA_CRC_type;
  _PLA_CRC_type PLA_CRC;

   typedef float _PLA_BZ_type;
  _PLA_BZ_type PLA_BZ;

   typedef uint8_t _PLABrkRqtSt_type;
  _PLABrkRqtSt_type PLABrkRqtSt;

   typedef float _PLAExpStrWhlAngle_type;
  _PLAExpStrWhlAngle_type PLAExpStrWhlAngle;

   typedef uint8_t _PLAExpStrWhlAngleDrt_type;
  _PLAExpStrWhlAngleDrt_type PLAExpStrWhlAngleDrt;

   typedef float _PLARequestStatus_type;
  _PLARequestStatus_type PLARequestStatus;

   typedef float _PLABrkTorque_type;
  _PLABrkTorque_type PLABrkTorque;

   typedef float _PLABrkDeceleration_type;
  _PLABrkDeceleration_type PLABrkDeceleration;

   typedef uint8_t _PLABrkEnable_type;
  _PLABrkEnable_type PLABrkEnable;

   typedef uint8_t _BrkTrqAndDeceSwt_type;
  _BrkTrqAndDeceSwt_type BrkTrqAndDeceSwt;

   typedef uint8_t _PLAParking_type;
  _PLAParking_type PLAParking;

   typedef float _PLAPrkDistance_type;
  _PLAPrkDistance_type PLAPrkDistance;

   typedef uint8_t _PLASignalTxCyclic_type;
  _PLASignalTxCyclic_type PLASignalTxCyclic;

   typedef uint8_t _YawState_type;
  _YawState_type YawState;

   typedef uint8_t _axState_type;
  _axState_type axState;

   typedef uint8_t _ayState_type;
  _ayState_type ayState;

   typedef float _ay_type;
  _ay_type ay;

   typedef float _ax_type;
  _ax_type ax;

   typedef float _YawRate_type;
  _YawRate_type YawRate;

   typedef uint8_t _YawToRight_type;
  _YawToRight_type YawToRight;

   typedef uint8_t _BrakePressureState_type;
  _BrakePressureState_type BrakePressureState;

   typedef float _BrakePressure_type;
  _BrakePressure_type BrakePressure;

   typedef float _LF_WhlSpdDrt_type;
  _LF_WhlSpdDrt_type LF_WhlSpdDrt;

   typedef float _LR_WhlSpdDrt_type;
  _LR_WhlSpdDrt_type LR_WhlSpdDrt;

   typedef float _RF_WhlSpdDrt_type;
  _RF_WhlSpdDrt_type RF_WhlSpdDrt;

   typedef float _RR_WhlSpdDrt_type;
  _RR_WhlSpdDrt_type RR_WhlSpdDrt;

   typedef float _ACC_02CRC_type;
  _ACC_02CRC_type ACC_02CRC;

   typedef float _ACC_02BZ_type;
  _ACC_02BZ_type ACC_02BZ;

   typedef float _ExpectedSpeed_type;
  _ExpectedSpeed_type ExpectedSpeed;

   typedef float _SpacingFactor_type;
  _SpacingFactor_type SpacingFactor;

   typedef float _NoiseAlarm_type;
  _NoiseAlarm_type NoiseAlarm;

   typedef float _SetSpacing_type;
  _SetSpacing_type SetSpacing;

   typedef uint8_t _ImageAlarm_type;
  _ImageAlarm_type ImageAlarm;

   typedef float _ACC02Status_type;
  _ACC02Status_type ACC02Status;

   typedef float _ACC_06CRC_type;
  _ACC_06CRC_type ACC_06CRC;

   typedef float _ACC_06BZ_type;
  _ACC_06BZ_type ACC_06BZ;

   typedef float _aLowerDeviation_type;
  _aLowerDeviation_type aLowerDeviation;

   typedef float _aExpectedValue_type;
  _aExpectedValue_type aExpectedValue;

   typedef float _aUpperDeviation_type;
  _aUpperDeviation_type aUpperDeviation;

   typedef float _DclrtGradRmdValue_type;
  _DclrtGradRmdValue_type DclrtGradRmdValue;

   typedef float _AclrtGradRmdValue_type;
  _AclrtGradRmdValue_type AclrtGradRmdValue;

   typedef uint8_t _StartRequest06_type;
  _StartRequest06_type StartRequest06;

   typedef uint8_t _ParkingRequest06_type;
  _ParkingRequest06_type ParkingRequest06;

   typedef float _ACC06Status_type;
  _ACC06Status_type ACC06Status;

   typedef float _ACC_07CRC_type;
  _ACC_07CRC_type ACC_07CRC;

   typedef float _ACC_07BZ_type;
  _ACC_07BZ_type ACC_07BZ;

   typedef float _ParkingDistance_type;
  _ParkingDistance_type ParkingDistance;

   typedef uint8_t _ParkingRequest07_type;
  _ParkingRequest07_type ParkingRequest07;

   typedef uint8_t _StartRequest07_type;
  _StartRequest07_type StartRequest07;

   typedef uint8_t _aExpValue_type;
  _aExpValue_type aExpValue;

   typedef float _EPBFaultStatus_type;
  _EPBFaultStatus_type EPBFaultStatus;

   typedef float _EPBSwitch_type;
  _EPBSwitch_type EPBSwitch;

   typedef uint8_t _EPBSwitchState_type;
  _EPBSwitchState_type EPBSwitchState;

   typedef float _EPB_PressingForce_type;
  _EPB_PressingForce_type EPB_PressingForce;

   typedef float _EPB_Status_type;
  _EPB_Status_type EPB_Status;

   typedef float _TSK_status_type;
  _TSK_status_type TSK_status;




  typedef boost::shared_ptr< ::tourancan::can_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::tourancan::can_<ContainerAllocator> const> ConstPtr;

}; // struct can_

typedef ::tourancan::can_<std::allocator<void> > can;

typedef boost::shared_ptr< ::tourancan::can > canPtr;
typedef boost::shared_ptr< ::tourancan::can const> canConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::tourancan::can_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::tourancan::can_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace tourancan

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'tourancan': ['/media/xiesc/Xie Shichao/catkin_can/src/tourancan/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::tourancan::can_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::tourancan::can_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::tourancan::can_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::tourancan::can_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::tourancan::can_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::tourancan::can_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::tourancan::can_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ab6878f5a479e92947f700b3b07d7f13";
  }

  static const char* value(const ::tourancan::can_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xab6878f5a479e929ULL;
  static const uint64_t static_value2 = 0x47f700b3b07d7f13ULL;
};

template<class ContainerAllocator>
struct DataType< ::tourancan::can_<ContainerAllocator> >
{
  static const char* value()
  {
    return "tourancan/can";
  }

  static const char* value(const ::tourancan::can_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::tourancan::can_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint8 LWI_Sensorstatus\n\
uint8 LWI_StrWhlAngleSt\n\
float32 LWI_StrWhlAngleSize \n\
uint8 LWI_StrWhlAngleDrt\n\
uint8 LWI_StrWhlSpeedDrt\n\
float32 LWI_StrWhlSpeedSize\n\
\n\
float32 Stalls\n\
float32 TargetStalls\n\
\n\
uint8 EngineSpeedState\n\
float32 EngineSpeed\n\
\n\
\n\
uint8 ACCSignalContinuity\n\
float32 Speed \n\
uint8 ESP_SystemStatus\n\
uint8 SpeedState\n\
\n\
float32 LF_WhlSpd\n\
float32 LR_WhlSpd\n\
float32 RF_WhlSpd\n\
float32 RR_WhlSpd\n\
\n\
float32 aPedalPercent\n\
uint8 aPedalPercentSt\n\
float32 ThrottleGradientSize\n\
uint8 ThrottleGradientPN\n\
uint8 EngNeutralTorque\n\
\n\
\n\
uint8 BrakeSwitch\n\
\n\
float32 EPSRxHCA_Status\n\
float32 EPS_StrWhlTorque \n\
uint8 EPS_StrWhlTorqueDrt\n\
uint8 EPS_StrWhlTorqueSt\n\
\n\
float32 ExpStrWhlTorque\n\
uint8 HCATranCycle\n\
uint8 ExpStrWhlTorqueDrt\n\
float32 HCA_Status\n\
\n\
float32 EngTorqueCoefficient\n\
\n\
float32 ThtottlePosition\n\
float32 aPedalPosition\n\
\n\
float32 PLA_CRC\n\
float32 PLA_BZ\n\
uint8 PLABrkRqtSt\n\
float32 PLAExpStrWhlAngle\n\
uint8 PLAExpStrWhlAngleDrt\n\
float32 PLARequestStatus\n\
float32 PLABrkTorque\n\
float32 PLABrkDeceleration\n\
uint8 PLABrkEnable\n\
uint8 BrkTrqAndDeceSwt\n\
uint8 PLAParking\n\
float32 PLAPrkDistance\n\
uint8 PLASignalTxCyclic\n\
\n\
uint8 YawState\n\
uint8 axState\n\
uint8 ayState\n\
float32 ay \n\
float32 ax\n\
float32 YawRate\n\
uint8 YawToRight\n\
\n\
uint8 BrakePressureState\n\
float32 BrakePressure\n\
float32 LF_WhlSpdDrt\n\
float32 LR_WhlSpdDrt\n\
float32 RF_WhlSpdDrt\n\
float32 RR_WhlSpdDrt\n\
\n\
\n\
\n\
float32 ACC_02CRC\n\
float32 ACC_02BZ\n\
float32 ExpectedSpeed  \n\
float32 SpacingFactor\n\
float32 NoiseAlarm\n\
float32 SetSpacing\n\
uint8 ImageAlarm\n\
float32 ACC02Status\n\
\n\
\n\
float32 ACC_06CRC\n\
float32 ACC_06BZ\n\
float32 aLowerDeviation\n\
float32 aExpectedValue \n\
float32 aUpperDeviation\n\
float32 DclrtGradRmdValue\n\
float32 AclrtGradRmdValue\n\
uint8 StartRequest06\n\
uint8 ParkingRequest06\n\
float32 ACC06Status\n\
\n\
float32 ACC_07CRC\n\
float32 ACC_07BZ\n\
float32 ParkingDistance\n\
uint8 ParkingRequest07\n\
uint8 StartRequest07\n\
uint8 aExpValue\n\
\n\
float32 EPBFaultStatus\n\
float32 EPBSwitch\n\
uint8 EPBSwitchState\n\
float32 EPB_PressingForce\n\
float32 EPB_Status\n\
\n\
float32 TSK_status\n\
\n\
\n\
";
  }

  static const char* value(const ::tourancan::can_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::tourancan::can_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.LWI_Sensorstatus);
      stream.next(m.LWI_StrWhlAngleSt);
      stream.next(m.LWI_StrWhlAngleSize);
      stream.next(m.LWI_StrWhlAngleDrt);
      stream.next(m.LWI_StrWhlSpeedDrt);
      stream.next(m.LWI_StrWhlSpeedSize);
      stream.next(m.Stalls);
      stream.next(m.TargetStalls);
      stream.next(m.EngineSpeedState);
      stream.next(m.EngineSpeed);
      stream.next(m.ACCSignalContinuity);
      stream.next(m.Speed);
      stream.next(m.ESP_SystemStatus);
      stream.next(m.SpeedState);
      stream.next(m.LF_WhlSpd);
      stream.next(m.LR_WhlSpd);
      stream.next(m.RF_WhlSpd);
      stream.next(m.RR_WhlSpd);
      stream.next(m.aPedalPercent);
      stream.next(m.aPedalPercentSt);
      stream.next(m.ThrottleGradientSize);
      stream.next(m.ThrottleGradientPN);
      stream.next(m.EngNeutralTorque);
      stream.next(m.BrakeSwitch);
      stream.next(m.EPSRxHCA_Status);
      stream.next(m.EPS_StrWhlTorque);
      stream.next(m.EPS_StrWhlTorqueDrt);
      stream.next(m.EPS_StrWhlTorqueSt);
      stream.next(m.ExpStrWhlTorque);
      stream.next(m.HCATranCycle);
      stream.next(m.ExpStrWhlTorqueDrt);
      stream.next(m.HCA_Status);
      stream.next(m.EngTorqueCoefficient);
      stream.next(m.ThtottlePosition);
      stream.next(m.aPedalPosition);
      stream.next(m.PLA_CRC);
      stream.next(m.PLA_BZ);
      stream.next(m.PLABrkRqtSt);
      stream.next(m.PLAExpStrWhlAngle);
      stream.next(m.PLAExpStrWhlAngleDrt);
      stream.next(m.PLARequestStatus);
      stream.next(m.PLABrkTorque);
      stream.next(m.PLABrkDeceleration);
      stream.next(m.PLABrkEnable);
      stream.next(m.BrkTrqAndDeceSwt);
      stream.next(m.PLAParking);
      stream.next(m.PLAPrkDistance);
      stream.next(m.PLASignalTxCyclic);
      stream.next(m.YawState);
      stream.next(m.axState);
      stream.next(m.ayState);
      stream.next(m.ay);
      stream.next(m.ax);
      stream.next(m.YawRate);
      stream.next(m.YawToRight);
      stream.next(m.BrakePressureState);
      stream.next(m.BrakePressure);
      stream.next(m.LF_WhlSpdDrt);
      stream.next(m.LR_WhlSpdDrt);
      stream.next(m.RF_WhlSpdDrt);
      stream.next(m.RR_WhlSpdDrt);
      stream.next(m.ACC_02CRC);
      stream.next(m.ACC_02BZ);
      stream.next(m.ExpectedSpeed);
      stream.next(m.SpacingFactor);
      stream.next(m.NoiseAlarm);
      stream.next(m.SetSpacing);
      stream.next(m.ImageAlarm);
      stream.next(m.ACC02Status);
      stream.next(m.ACC_06CRC);
      stream.next(m.ACC_06BZ);
      stream.next(m.aLowerDeviation);
      stream.next(m.aExpectedValue);
      stream.next(m.aUpperDeviation);
      stream.next(m.DclrtGradRmdValue);
      stream.next(m.AclrtGradRmdValue);
      stream.next(m.StartRequest06);
      stream.next(m.ParkingRequest06);
      stream.next(m.ACC06Status);
      stream.next(m.ACC_07CRC);
      stream.next(m.ACC_07BZ);
      stream.next(m.ParkingDistance);
      stream.next(m.ParkingRequest07);
      stream.next(m.StartRequest07);
      stream.next(m.aExpValue);
      stream.next(m.EPBFaultStatus);
      stream.next(m.EPBSwitch);
      stream.next(m.EPBSwitchState);
      stream.next(m.EPB_PressingForce);
      stream.next(m.EPB_Status);
      stream.next(m.TSK_status);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct can_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::tourancan::can_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::tourancan::can_<ContainerAllocator>& v)
  {
    s << indent << "LWI_Sensorstatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.LWI_Sensorstatus);
    s << indent << "LWI_StrWhlAngleSt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.LWI_StrWhlAngleSt);
    s << indent << "LWI_StrWhlAngleSize: ";
    Printer<float>::stream(s, indent + "  ", v.LWI_StrWhlAngleSize);
    s << indent << "LWI_StrWhlAngleDrt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.LWI_StrWhlAngleDrt);
    s << indent << "LWI_StrWhlSpeedDrt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.LWI_StrWhlSpeedDrt);
    s << indent << "LWI_StrWhlSpeedSize: ";
    Printer<float>::stream(s, indent + "  ", v.LWI_StrWhlSpeedSize);
    s << indent << "Stalls: ";
    Printer<float>::stream(s, indent + "  ", v.Stalls);
    s << indent << "TargetStalls: ";
    Printer<float>::stream(s, indent + "  ", v.TargetStalls);
    s << indent << "EngineSpeedState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.EngineSpeedState);
    s << indent << "EngineSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.EngineSpeed);
    s << indent << "ACCSignalContinuity: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ACCSignalContinuity);
    s << indent << "Speed: ";
    Printer<float>::stream(s, indent + "  ", v.Speed);
    s << indent << "ESP_SystemStatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ESP_SystemStatus);
    s << indent << "SpeedState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.SpeedState);
    s << indent << "LF_WhlSpd: ";
    Printer<float>::stream(s, indent + "  ", v.LF_WhlSpd);
    s << indent << "LR_WhlSpd: ";
    Printer<float>::stream(s, indent + "  ", v.LR_WhlSpd);
    s << indent << "RF_WhlSpd: ";
    Printer<float>::stream(s, indent + "  ", v.RF_WhlSpd);
    s << indent << "RR_WhlSpd: ";
    Printer<float>::stream(s, indent + "  ", v.RR_WhlSpd);
    s << indent << "aPedalPercent: ";
    Printer<float>::stream(s, indent + "  ", v.aPedalPercent);
    s << indent << "aPedalPercentSt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.aPedalPercentSt);
    s << indent << "ThrottleGradientSize: ";
    Printer<float>::stream(s, indent + "  ", v.ThrottleGradientSize);
    s << indent << "ThrottleGradientPN: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ThrottleGradientPN);
    s << indent << "EngNeutralTorque: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.EngNeutralTorque);
    s << indent << "BrakeSwitch: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.BrakeSwitch);
    s << indent << "EPSRxHCA_Status: ";
    Printer<float>::stream(s, indent + "  ", v.EPSRxHCA_Status);
    s << indent << "EPS_StrWhlTorque: ";
    Printer<float>::stream(s, indent + "  ", v.EPS_StrWhlTorque);
    s << indent << "EPS_StrWhlTorqueDrt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.EPS_StrWhlTorqueDrt);
    s << indent << "EPS_StrWhlTorqueSt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.EPS_StrWhlTorqueSt);
    s << indent << "ExpStrWhlTorque: ";
    Printer<float>::stream(s, indent + "  ", v.ExpStrWhlTorque);
    s << indent << "HCATranCycle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.HCATranCycle);
    s << indent << "ExpStrWhlTorqueDrt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ExpStrWhlTorqueDrt);
    s << indent << "HCA_Status: ";
    Printer<float>::stream(s, indent + "  ", v.HCA_Status);
    s << indent << "EngTorqueCoefficient: ";
    Printer<float>::stream(s, indent + "  ", v.EngTorqueCoefficient);
    s << indent << "ThtottlePosition: ";
    Printer<float>::stream(s, indent + "  ", v.ThtottlePosition);
    s << indent << "aPedalPosition: ";
    Printer<float>::stream(s, indent + "  ", v.aPedalPosition);
    s << indent << "PLA_CRC: ";
    Printer<float>::stream(s, indent + "  ", v.PLA_CRC);
    s << indent << "PLA_BZ: ";
    Printer<float>::stream(s, indent + "  ", v.PLA_BZ);
    s << indent << "PLABrkRqtSt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.PLABrkRqtSt);
    s << indent << "PLAExpStrWhlAngle: ";
    Printer<float>::stream(s, indent + "  ", v.PLAExpStrWhlAngle);
    s << indent << "PLAExpStrWhlAngleDrt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.PLAExpStrWhlAngleDrt);
    s << indent << "PLARequestStatus: ";
    Printer<float>::stream(s, indent + "  ", v.PLARequestStatus);
    s << indent << "PLABrkTorque: ";
    Printer<float>::stream(s, indent + "  ", v.PLABrkTorque);
    s << indent << "PLABrkDeceleration: ";
    Printer<float>::stream(s, indent + "  ", v.PLABrkDeceleration);
    s << indent << "PLABrkEnable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.PLABrkEnable);
    s << indent << "BrkTrqAndDeceSwt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.BrkTrqAndDeceSwt);
    s << indent << "PLAParking: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.PLAParking);
    s << indent << "PLAPrkDistance: ";
    Printer<float>::stream(s, indent + "  ", v.PLAPrkDistance);
    s << indent << "PLASignalTxCyclic: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.PLASignalTxCyclic);
    s << indent << "YawState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.YawState);
    s << indent << "axState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.axState);
    s << indent << "ayState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ayState);
    s << indent << "ay: ";
    Printer<float>::stream(s, indent + "  ", v.ay);
    s << indent << "ax: ";
    Printer<float>::stream(s, indent + "  ", v.ax);
    s << indent << "YawRate: ";
    Printer<float>::stream(s, indent + "  ", v.YawRate);
    s << indent << "YawToRight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.YawToRight);
    s << indent << "BrakePressureState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.BrakePressureState);
    s << indent << "BrakePressure: ";
    Printer<float>::stream(s, indent + "  ", v.BrakePressure);
    s << indent << "LF_WhlSpdDrt: ";
    Printer<float>::stream(s, indent + "  ", v.LF_WhlSpdDrt);
    s << indent << "LR_WhlSpdDrt: ";
    Printer<float>::stream(s, indent + "  ", v.LR_WhlSpdDrt);
    s << indent << "RF_WhlSpdDrt: ";
    Printer<float>::stream(s, indent + "  ", v.RF_WhlSpdDrt);
    s << indent << "RR_WhlSpdDrt: ";
    Printer<float>::stream(s, indent + "  ", v.RR_WhlSpdDrt);
    s << indent << "ACC_02CRC: ";
    Printer<float>::stream(s, indent + "  ", v.ACC_02CRC);
    s << indent << "ACC_02BZ: ";
    Printer<float>::stream(s, indent + "  ", v.ACC_02BZ);
    s << indent << "ExpectedSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.ExpectedSpeed);
    s << indent << "SpacingFactor: ";
    Printer<float>::stream(s, indent + "  ", v.SpacingFactor);
    s << indent << "NoiseAlarm: ";
    Printer<float>::stream(s, indent + "  ", v.NoiseAlarm);
    s << indent << "SetSpacing: ";
    Printer<float>::stream(s, indent + "  ", v.SetSpacing);
    s << indent << "ImageAlarm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ImageAlarm);
    s << indent << "ACC02Status: ";
    Printer<float>::stream(s, indent + "  ", v.ACC02Status);
    s << indent << "ACC_06CRC: ";
    Printer<float>::stream(s, indent + "  ", v.ACC_06CRC);
    s << indent << "ACC_06BZ: ";
    Printer<float>::stream(s, indent + "  ", v.ACC_06BZ);
    s << indent << "aLowerDeviation: ";
    Printer<float>::stream(s, indent + "  ", v.aLowerDeviation);
    s << indent << "aExpectedValue: ";
    Printer<float>::stream(s, indent + "  ", v.aExpectedValue);
    s << indent << "aUpperDeviation: ";
    Printer<float>::stream(s, indent + "  ", v.aUpperDeviation);
    s << indent << "DclrtGradRmdValue: ";
    Printer<float>::stream(s, indent + "  ", v.DclrtGradRmdValue);
    s << indent << "AclrtGradRmdValue: ";
    Printer<float>::stream(s, indent + "  ", v.AclrtGradRmdValue);
    s << indent << "StartRequest06: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StartRequest06);
    s << indent << "ParkingRequest06: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ParkingRequest06);
    s << indent << "ACC06Status: ";
    Printer<float>::stream(s, indent + "  ", v.ACC06Status);
    s << indent << "ACC_07CRC: ";
    Printer<float>::stream(s, indent + "  ", v.ACC_07CRC);
    s << indent << "ACC_07BZ: ";
    Printer<float>::stream(s, indent + "  ", v.ACC_07BZ);
    s << indent << "ParkingDistance: ";
    Printer<float>::stream(s, indent + "  ", v.ParkingDistance);
    s << indent << "ParkingRequest07: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ParkingRequest07);
    s << indent << "StartRequest07: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StartRequest07);
    s << indent << "aExpValue: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.aExpValue);
    s << indent << "EPBFaultStatus: ";
    Printer<float>::stream(s, indent + "  ", v.EPBFaultStatus);
    s << indent << "EPBSwitch: ";
    Printer<float>::stream(s, indent + "  ", v.EPBSwitch);
    s << indent << "EPBSwitchState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.EPBSwitchState);
    s << indent << "EPB_PressingForce: ";
    Printer<float>::stream(s, indent + "  ", v.EPB_PressingForce);
    s << indent << "EPB_Status: ";
    Printer<float>::stream(s, indent + "  ", v.EPB_Status);
    s << indent << "TSK_status: ";
    Printer<float>::stream(s, indent + "  ", v.TSK_status);
  }
};

} // namespace message_operations
} // namespace ros

#endif // TOURANCAN_MESSAGE_CAN_H
